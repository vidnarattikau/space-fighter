<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Èõ∑ÈúÜÊàòÊú∫ Thunder Fighter</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
html, body {
  width: 100%;
  height: 100%;
  overflow: hidden;
  background: #000;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", sans-serif;
}
#gameCanvas {
  display: block;
  width: 100vw;
  height: 100vh;
  touch-action: none;
  cursor: none;
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<script>
// ========================================
// Èõ∑ÈúÜÊàòÊú∫ - Thunder Fighter
// ‰∏Ä‰∏™ÂÆåÊï¥ÁöÑÁ∫µÂêëÂç∑ËΩ¥Â∞ÑÂáªÊ∏∏Êàè
// ========================================

(function() {
'use strict';

// ========================================
// 1. ÂàùÂßãÂåñ Canvas Âíå‰∏ä‰∏ãÊñá
// ========================================
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let WIDTH = window.innerWidth;
let HEIGHT = window.innerHeight;

function resizeCanvas() {
  WIDTH = window.innerWidth;
  HEIGHT = window.innerHeight;
  canvas.width = WIDTH;
  canvas.height = HEIGHT;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// ========================================
// 2. Ê∏∏ÊàèÁä∂ÊÄÅÁÆ°ÁêÜ
// ========================================
const GameState = {
  START: 'start',
  PLAYING: 'playing',
  PAUSED: 'paused',
  GAMEOVER: 'gameover'
};

const game = {
  state: GameState.START,
  score: 0,
  bestScore: parseInt(localStorage.getItem('thunderFighterBest') || '0'),
  wave: 1,
  kills: 0,
  combo: 0,
  comboTimer: 0,
  maxCombo: 0,
  time: 0,
  flashTimer: 0,
  shakeX: 0,
  shakeY: 0,
  shakeIntensity: 0
};

// ========================================
// 3. Èü≥ÊïàÁ≥ªÁªü (Web Audio API)
// ========================================
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
const sounds = {
  enabled: true,
  
  shoot() {
    if (!this.enabled) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = 800;
    gain.gain.value = 0.05;
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
    osc.stop(audioCtx.currentTime + 0.05);
  },
  
  explosion() {
    if (!this.enabled) return;
    const bufferSize = audioCtx.sampleRate * 0.2;
    const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.3));
    }
    const source = audioCtx.createBufferSource();
    const gain = audioCtx.createGain();
    source.buffer = buffer;
    source.connect(gain);
    gain.connect(audioCtx.destination);
    gain.gain.value = 0.15;
    source.start();
  },
  
  powerup() {
    if (!this.enabled) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.15);
    gain.gain.value = 0.1;
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.15);
    osc.stop(audioCtx.currentTime + 0.15);
  },
  
  bomb() {
    if (!this.enabled) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.setValueAtTime(150, audioCtx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(50, audioCtx.currentTime + 0.4);
    gain.gain.value = 0.2;
    osc.start();
    gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.4);
    osc.stop(audioCtx.currentTime + 0.4);
  },
  
  warning() {
    if (!this.enabled) return;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = 600;
    osc.type = 'square';
    gain.gain.value = 0.08;
    osc.start();
    osc.stop(audioCtx.currentTime + 0.1);
  }
};

// ========================================
// 4. Á≤íÂ≠êÁ≥ªÁªü
// ========================================
const particles = [];

class Particle {
  constructor(x, y, color, vx, vy, life = 60, size = 3) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.color = color;
    this.life = life;
    this.maxLife = life;
    this.size = size;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.vy += 0.15; // ÈáçÂäõ
    this.life--;
  }
  
  draw() {
    const alpha = this.life / this.maxLife;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = this.color;
    ctx.fillRect(this.x - this.size/2, this.y - this.size/2, this.size, this.size);
    ctx.globalAlpha = 1;
  }
  
  isDead() {
    return this.life <= 0;
  }
}

function createExplosion(x, y, count = 30, colors = ['#ff6b00', '#ff3300', '#ffaa00', '#fff']) {
  for (let i = 0; i < count; i++) {
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 4 + 2;
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    const color = colors[Math.floor(Math.random() * colors.length)];
    const size = Math.random() * 4 + 2;
    particles.push(new Particle(x, y, color, vx, vy, 30 + Math.random() * 30, size));
  }
}

// ========================================
// 5. ËÉåÊôØÊòüÁ©∫Á≥ªÁªü
// ========================================
const stars = [];

class Star {
  constructor() {
    this.reset();
  }
  
  reset() {
    this.x = Math.random() * WIDTH;
    this.y = Math.random() * HEIGHT;
    this.z = Math.random() * 3;
    this.speed = 0.5 + this.z * 0.5;
    this.size = 1 + this.z * 0.5;
  }
  
  update() {
    this.y += this.speed;
    if (this.y > HEIGHT + 10) {
      this.y = -10;
      this.x = Math.random() * WIDTH;
    }
  }
  
  draw() {
    const brightness = Math.floor(100 + this.z * 50);
    ctx.fillStyle = `hsl(220, 80%, ${brightness}%)`;
    ctx.fillRect(this.x, this.y, this.size, this.size * 2);
  }
}

// ÂàùÂßãÂåñÊòüÊòü
for (let i = 0; i < 100; i++) {
  stars.push(new Star());
}

// ========================================
// 6. Áé©ÂÆ∂È£ûËàπ
// ========================================
const player = {
  x: WIDTH / 2,
  y: HEIGHT - 150,
  width: 40,
  height: 50,
  hp: 100,
  maxHp: 100,
  weapon: 1,
  maxWeapon: 5,
  bombs: 2,
  shield: 0,
  invulnerable: 0,
  shootCooldown: 0,
  
  update() {
    if (this.shootCooldown > 0) this.shootCooldown--;
    if (this.shield > 0) this.shield--;
    if (this.invulnerable > 0) this.invulnerable--;
    
    // ËæπÁïåÊ£ÄÊµã
    this.x = Math.max(this.width/2, Math.min(WIDTH - this.width/2, this.x));
    this.y = Math.max(this.height/2, Math.min(HEIGHT - this.height/2, this.y));
    
    // Ëá™Âä®Â∞ÑÂáª
    if (game.state === GameState.PLAYING) {
      this.autoShoot();
    }
  },
  
  autoShoot() {
    const fireRate = [0, 8, 7, 6, 5, 4][this.weapon];
    if (this.shootCooldown <= 0) {
      this.shoot();
      this.shootCooldown = fireRate;
    }
  },
  
  shoot() {
    sounds.shoot();
    
    // ‰∏çÂêåÊ≠¶Âô®Á≠âÁ∫ßÁöÑÂ∞ÑÂáªÊ®°Âºè
    switch(this.weapon) {
      case 1: // ÂçïÂèë
        bullets.push(new Bullet(this.x, this.y - this.height/2, 0, -12));
        break;
      case 2: // ÂèåÂèë
        bullets.push(new Bullet(this.x - 12, this.y - this.height/2, 0, -12));
        bullets.push(new Bullet(this.x + 12, this.y - this.height/2, 0, -12));
        break;
      case 3: // ‰∏âÂèëÊï£Â∞Ñ
        bullets.push(new Bullet(this.x, this.y - this.height/2, 0, -13));
        bullets.push(new Bullet(this.x - 15, this.y - this.height/2, -1.5, -12));
        bullets.push(new Bullet(this.x + 15, this.y - this.height/2, 1.5, -12));
        break;
      case 4: // ÂõõÂèë + ‰æßÂêëÂØºÂºπ
        bullets.push(new Bullet(this.x - 10, this.y - this.height/2, 0, -13));
        bullets.push(new Bullet(this.x + 10, this.y - this.height/2, 0, -13));
        bullets.push(new Bullet(this.x - 20, this.y, -3, -10));
        bullets.push(new Bullet(this.x + 20, this.y, 3, -10));
        break;
      case 5: // ÂÖ®Â±èÂºπÂπï + ËøΩË∏™ÂØºÂºπ
        for (let i = -2; i <= 2; i++) {
          bullets.push(new Bullet(this.x + i * 8, this.y - this.height/2, i * 0.8, -12));
        }
        // ËøΩË∏™ÂØºÂºπ‰ºöÂú® Bullet Á±ª‰∏≠ÂÆûÁé∞
        if (game.time % 20 === 0) {
          bullets.push(new HomingMissile(this.x - 25, this.y));
          bullets.push(new HomingMissile(this.x + 25, this.y));
        }
        break;
    }
  },
  
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    
    // Êä§ÁõæÊïàÊûú
    if (this.shield > 0) {
      const alpha = Math.min(0.6, this.shield / 100);
      ctx.globalAlpha = alpha;
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.arc(0, 0, this.width, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    // Êó†ÊïåÈó™ÁÉÅ
    if (this.invulnerable > 0 && Math.floor(game.time / 4) % 2 === 0) {
      ctx.globalAlpha = 0.5;
    }
    
    // ÁªòÂà∂ÊàòÊú∫‰∏ª‰Ωì
    ctx.fillStyle = '#00d4ff';
    ctx.beginPath();
    ctx.moveTo(0, -this.height/2);
    ctx.lineTo(-this.width/2 + 5, this.height/4);
    ctx.lineTo(-this.width/2, this.height/2);
    ctx.lineTo(0, this.height/3);
    ctx.lineTo(this.width/2, this.height/2);
    ctx.lineTo(this.width/2 - 5, this.height/4);
    ctx.closePath();
    ctx.fill();
    
    // È©æÈ©∂Ëà±
    ctx.fillStyle = '#ff6600';
    ctx.beginPath();
    ctx.arc(0, -5, 8, 0, Math.PI * 2);
    ctx.fill();
    
    // Êú∫Áøº
    ctx.fillStyle = '#0099cc';
    ctx.fillRect(-this.width/2, this.height/4, 10, 15);
    ctx.fillRect(this.width/2 - 10, this.height/4, 10, 15);
    
    // ÂºïÊìéÂÖâÊôï
    const gradient = ctx.createRadialGradient(0, this.height/2, 0, 0, this.height/2, 20);
    gradient.addColorStop(0, 'rgba(255, 150, 0, 0.8)');
    gradient.addColorStop(1, 'rgba(255, 50, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-15, this.height/2, 30, 20);
    
    ctx.restore();
  },
  
  takeDamage(amount) {
    if (this.shield > 0) {
      this.shield = 0;
      return;
    }
    if (this.invulnerable > 0) return;
    
    this.hp -= amount;
    this.invulnerable = 90;
    screenShake(15);
    
    if (this.hp <= 0) {
      this.hp = 0;
      gameOver();
    }
  },
  
  useBomb() {
    if (this.bombs <= 0) return;
    this.bombs--;
    sounds.bomb();
    game.flashTimer = 20;
    
    // Ê∏ÖÈô§ÊâÄÊúâÊïå‰∫∫ÂíåÂ≠êÂºπ
    enemies.forEach(e => {
      createExplosion(e.x, e.y, 40);
      game.score += e.scoreValue;
    });
    enemies.length = 0;
    enemyBullets.length = 0;
    
    screenShake(25);
  },
  
  upgrade(type) {
    switch(type) {
      case 'weapon':
        if (this.weapon < this.maxWeapon) {
          this.weapon++;
          sounds.powerup();
        }
        break;
      case 'hp':
        this.hp = Math.min(this.maxHp, this.hp + 40);
        sounds.powerup();
        break;
      case 'bomb':
        this.bombs++;
        sounds.powerup();
        break;
      case 'shield':
        this.shield = 180;
        sounds.powerup();
        break;
      case 'score':
        game.score += 500;
        sounds.powerup();
        break;
    }
  }
};

// ========================================
// 7. Â≠êÂºπÁ≥ªÁªü
// ========================================
const bullets = [];
const enemyBullets = [];

class Bullet {
  constructor(x, y, vx, vy) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.width = 4;
    this.height = 12;
    this.damage = 10;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
  }
  
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    
    // Â≠êÂºπÂÖâÊôï
    const gradient = ctx.createRadialGradient(0, 0, 0, 0, 0, 8);
    gradient.addColorStop(0, 'rgba(0, 255, 255, 0.8)');
    gradient.addColorStop(1, 'rgba(0, 255, 255, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-6, -6, 12, 12);
    
    // Â≠êÂºπ‰∏ª‰Ωì
    ctx.fillStyle = '#00ffff';
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    
    ctx.restore();
  }
  
  isOffScreen() {
    return this.y < -50 || this.y > HEIGHT + 50 || this.x < -50 || this.x > WIDTH + 50;
  }
}

class HomingMissile extends Bullet {
  constructor(x, y) {
    super(x, y, 0, -8);
    this.target = null;
    this.damage = 25;
    this.width = 6;
    this.height = 16;
  }
  
  update() {
    // ÂØªÊâæÊúÄËøëÁöÑÊïå‰∫∫
    if (!this.target || this.target.isDead) {
      let minDist = Infinity;
      enemies.forEach(e => {
        const dist = Math.hypot(e.x - this.x, e.y - this.y);
        if (dist < minDist) {
          minDist = dist;
          this.target = e;
        }
      });
    }
    
    // ËøΩË∏™ÁõÆÊ†á
    if (this.target && !this.target.isDead) {
      const dx = this.target.x - this.x;
      const dy = this.target.y - this.y;
      const angle = Math.atan2(dy, dx);
      this.vx += Math.cos(angle) * 0.5;
      this.vy += Math.sin(angle) * 0.5;
      
      // ÈôêÂà∂ÈÄüÂ∫¶
      const speed = Math.hypot(this.vx, this.vy);
      if (speed > 10) {
        this.vx = this.vx / speed * 10;
        this.vy = this.vy / speed * 10;
      }
    }
    
    this.x += this.vx;
    this.y += this.vy;
  }
  
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    const angle = Math.atan2(this.vy, this.vx);
    ctx.rotate(angle + Math.PI/2);
    
    // ÂØºÂºπÂ∞æÁÑ∞
    const gradient = ctx.createRadialGradient(0, this.height/2, 0, 0, this.height/2, 12);
    gradient.addColorStop(0, 'rgba(255, 150, 0, 0.9)');
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-8, this.height/2, 16, 15);
    
    // ÂØºÂºπ‰∏ª‰Ωì
    ctx.fillStyle = '#ff6600';
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(-3, -this.height/2, 6, 8);
    
    ctx.restore();
  }
}

class EnemyBullet {
  constructor(x, y, vx, vy) {
    this.x = x;
    this.y = y;
    this.vx = vx;
    this.vy = vy;
    this.radius = 5;
    this.damage = 15;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
  }
  
  draw() {
    // ÂÖâÊôï
    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
    gradient.addColorStop(0, 'rgba(255, 50, 50, 0.8)');
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // Â≠êÂºπ‰∏ª‰Ωì
    ctx.fillStyle = '#ff3333';
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.fill();
  }
  
  isOffScreen() {
    return this.y < -50 || this.y > HEIGHT + 50 || this.x < -50 || this.x > WIDTH + 50;
  }
}

// ========================================
// 8. Êïå‰∫∫Á≥ªÁªü
// ========================================
const enemies = [];

class Enemy {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.isDead = false;
    
    switch(type) {
      case 'small':
        this.width = 30;
        this.height = 30;
        this.hp = 20;
        this.maxHp = 20;
        this.speed = 2;
        this.scoreValue = 100;
        this.shootCooldown = 60 + Math.random() * 60;
        this.color = '#ff3333';
        break;
      case 'medium':
        this.width = 45;
        this.height = 40;
        this.hp = 50;
        this.maxHp = 50;
        this.speed = 1.5;
        this.scoreValue = 200;
        this.shootCooldown = 50 + Math.random() * 50;
        this.color = '#ff6600';
        break;
      case 'elite':
        this.width = 50;
        this.height = 50;
        this.hp = 100;
        this.maxHp = 100;
        this.speed = 1.2;
        this.scoreValue = 400;
        this.shootCooldown = 40 + Math.random() * 40;
        this.color = '#aa00ff';
        break;
      case 'boss':
        this.width = 120;
        this.height = 100;
        this.hp = 500 + game.wave * 100;
        this.maxHp = 500 + game.wave * 100;
        this.speed = 0.8;
        this.scoreValue = 2000;
        this.shootCooldown = 30;
        this.color = '#ff9900';
        this.phase = 0;
        break;
    }
    
    this.vx = (Math.random() - 0.5) * 2;
    this.vy = this.speed;
  }
  
  update() {
    this.x += this.vx;
    this.y += this.vy;
    
    // ËæπÁïåÂèçÂºπ
    if (this.x < this.width/2 || this.x > WIDTH - this.width/2) {
      this.vx *= -1;
    }
    
    // Â∞ÑÂáª
    this.shootCooldown--;
    if (this.shootCooldown <= 0) {
      this.shoot();
      this.shootCooldown = this.type === 'boss' ? 20 : 60 + Math.random() * 60;
    }
    
    // BossÁâπÊÆäË°å‰∏∫
    if (this.type === 'boss') {
      this.updateBoss();
    }
  }
  
  updateBoss() {
    // Boss‰ºöÂ∑¶Âè≥ÁßªÂä®
    if (this.y < 150) {
      this.vy = 0.3;
    } else {
      this.vy = 0;
    }
    
    // ÂàáÊç¢ÊîªÂáªÊ®°Âºè
    if (game.time % 200 === 0) {
      this.phase = (this.phase + 1) % 3;
    }
  }
  
  shoot() {
    if (this.type === 'boss') {
      this.shootBoss();
    } else {
      // ÊôÆÈÄöÂ∞ÑÂáªÔºöÊúùÂêëÁé©ÂÆ∂
      const dx = player.x - this.x;
      const dy = player.y - this.y;
      const angle = Math.atan2(dy, dx);
      const speed = 4;
      enemyBullets.push(new EnemyBullet(
        this.x,
        this.y + this.height/2,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed
      ));
    }
  }
  
  shootBoss() {
    switch(this.phase) {
      case 0: // ÊâáÂΩ¢ÂºπÂπï
        for (let i = -3; i <= 3; i++) {
          const angle = Math.PI/2 + i * 0.2;
          enemyBullets.push(new EnemyBullet(
            this.x,
            this.y + this.height/2,
            Math.cos(angle) * 5,
            Math.sin(angle) * 5
          ));
        }
        break;
      case 1: // ÁûÑÂáÜÂ∞ÑÂáª
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const angle = Math.atan2(dy, dx);
        for (let i = 0; i < 3; i++) {
          enemyBullets.push(new EnemyBullet(
            this.x + (i-1) * 30,
            this.y + this.height/2,
            Math.cos(angle) * 6,
            Math.sin(angle) * 6
          ));
        }
        break;
      case 2: // ÁéØÂΩ¢ÂºπÂπï
        for (let i = 0; i < 8; i++) {
          const a = (i / 8) * Math.PI * 2;
          enemyBullets.push(new EnemyBullet(
            this.x,
            this.y,
            Math.cos(a) * 4,
            Math.sin(a) * 4
          ));
        }
        break;
    }
  }
  
  draw() {
    ctx.save();
    ctx.translate(this.x, this.y);
    
    // Á≤æËã±Êïå‰∫∫ÁöÑÊä§ÁõæÊïàÊûú
    if (this.type === 'elite') {
      ctx.globalAlpha = 0.4;
      ctx.strokeStyle = '#aa00ff';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(0, 0, this.width/2 + 5, 0, Math.PI * 2);
      ctx.stroke();
      ctx.globalAlpha = 1;
    }
    
    if (this.type === 'boss') {
      this.drawBoss();
    } else if (this.type === 'small') {
      this.drawSmall();
    } else if (this.type === 'medium') {
      this.drawMedium();
    } else if (this.type === 'elite') {
      this.drawElite();
    }
    
    ctx.restore();
    
    // HPÊù°
    if (this.type !== 'small') {
      this.drawHPBar();
    }
  }
  
  drawSmall() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0, this.height/2);
    ctx.lineTo(-this.width/2, -this.height/2);
    ctx.lineTo(this.width/2, -this.height/2);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = '#ff6666';
    ctx.fillRect(-5, 0, 10, 8);
  }
  
  drawMedium() {
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    
    ctx.fillStyle = '#ffaa00';
    ctx.fillRect(-this.width/2, -this.height/2 + 10, 10, 20);
    ctx.fillRect(this.width/2 - 10, -this.height/2 + 10, 10, 20);
    
    ctx.fillStyle = '#cc0000';
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.fill();
  }
  
  drawElite() {
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.moveTo(0, -this.height/2);
    ctx.lineTo(this.width/2, 0);
    ctx.lineTo(0, this.height/2);
    ctx.lineTo(-this.width/2, 0);
    ctx.closePath();
    ctx.fill();
    
    ctx.fillStyle = '#dd00ff';
    ctx.beginPath();
    ctx.arc(0, 0, 12, 0, Math.PI * 2);
    ctx.fill();
    
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(0, 0, 8, 0, Math.PI * 2);
    ctx.stroke();
  }
  
  drawBoss() {
    // Boss‰∏ª‰Ωì
    ctx.fillStyle = this.color;
    ctx.fillRect(-this.width/2, -this.height/2, this.width, this.height);
    
    // ÁÇÆÂ°î
    ctx.fillStyle = '#cc6600';
    ctx.fillRect(-40, -20, 20, 30);
    ctx.fillRect(20, -20, 20, 30);
    
    // È©æÈ©∂Ëà±
    ctx.fillStyle = '#00ffff';
    ctx.beginPath();
    ctx.arc(0, -10, 15, 0, Math.PI * 2);
    ctx.fill();
    
    // ÂºïÊìé
    const gradient = ctx.createRadialGradient(0, this.height/2, 0, 0, this.height/2, 30);
    gradient.addColorStop(0, 'rgba(255, 0, 0, 0.9)');
    gradient.addColorStop(1, 'rgba(255, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(-this.width/3, this.height/2, this.width * 2/3, 25);
  }
  
  drawHPBar() {
    const barWidth = this.width + 10;
    const barHeight = 5;
    const barX = this.x - barWidth/2;
    const barY = this.y - this.height/2 - 15;
    
    // ËÉåÊôØ
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(barX, barY, barWidth, barHeight);
    
    // HP
    const hpPercent = this.hp / this.maxHp;
    ctx.fillStyle = hpPercent > 0.5 ? '#00ff00' : hpPercent > 0.25 ? '#ffaa00' : '#ff3333';
    ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
    
    // ËæπÊ°Ü
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.strokeRect(barX, barY, barWidth, barHeight);
  }
  
  takeDamage(amount) {
    this.hp -= amount;
    if (this.hp <= 0) {
      this.die();
    }
  }
  
  die() {
    this.isDead = true;
    sounds.explosion();
    createExplosion(this.x, this.y, this.type === 'boss' ? 60 : 30);
    game.score += this.scoreValue;
    game.kills++;
    
    // ËøûÂáªÁ≥ªÁªü
    game.combo++;
    game.comboTimer = 120;
    if (game.combo > game.maxCombo) game.maxCombo = game.combo;
    
    // ÊéâËêΩÈÅìÂÖ∑
    if (Math.random() < 0.3) {
      this.dropPowerup();
    }
    
    if (this.type === 'boss') {
      screenShake(30);
      game.wave++;
    }
  }
  
  dropPowerup() {
    const types = ['weapon', 'hp', 'bomb', 'shield', 'score'];
    const weights = [0.3, 0.3, 0.15, 0.15, 0.1];
    let rand = Math.random();
    let type = types[0];
    
    for (let i = 0; i < types.length; i++) {
      rand -= weights[i];
      if (rand < 0) {
        type = types[i];
        break;
      }
    }
    
    powerups.push(new Powerup(this.x, this.y, type));
  }
  
  isOffScreen() {
    return this.y > HEIGHT + 100;
  }
}

// ========================================
// 9. ÈÅìÂÖ∑Á≥ªÁªü
// ========================================
const powerups = [];

class Powerup {
  constructor(x, y, type) {
    this.x = x;
    this.y = y;
    this.type = type;
    this.vy = 2;
    this.radius = 15;
    this.collected = false;
    
    const config = {
      weapon: { emoji: '‚¨ÜÔ∏è', color: '#00aaff' },
      hp: { emoji: '‚ù§Ô∏è', color: '#ff3333' },
      bomb: { emoji: 'üí£', color: '#ffaa00' },
      shield: { emoji: 'üõ°Ô∏è', color: '#00ffff' },
      score: { emoji: '‚≠ê', color: '#ffff00' }
    };
    
    this.emoji = config[type].emoji;
    this.color = config[type].color;
  }
  
  update() {
    this.y += this.vy;
    
    // Ê£ÄÊµãÁé©ÂÆ∂ÊãæÂèñ
    const dist = Math.hypot(player.x - this.x, player.y - this.y);
    if (dist < this.radius + player.width/2) {
      this.collect();
    }
  }
  
  draw() {
    // ÂÖâÊôï
    const gradient = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.radius * 2);
    gradient.addColorStop(0, this.color + '80');
    gradient.addColorStop(1, this.color + '00');
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius * 2, 0, Math.PI * 2);
    ctx.fill();
    
    // ËæπÊ°Ü
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
    ctx.stroke();
    
    // Emoji
    ctx.font = '24px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(this.emoji, this.x, this.y);
  }
  
  collect() {
    this.collected = true;
    player.upgrade(this.type);
    
    // ÊãæÂèñÁâπÊïà
    for (let i = 0; i < 10; i++) {
      const angle = (i / 10) * Math.PI * 2;
      const speed = 3;
      particles.push(new Particle(
        this.x,
        this.y,
        this.color,
        Math.cos(angle) * speed,
        Math.sin(angle) * speed,
        30,
        3
      ));
    }
  }
  
  isOffScreen() {
    return this.y > HEIGHT + 50;
  }
}

// ========================================
// 10. Ê≥¢Ê¨°ÁîüÊàêÁ≥ªÁªü
// ========================================
let waveTimer = 0;
let nextWaveDelay = 180;

function spawnWave() {
  const wave = game.wave;
  
  // BossÊ≥¢Ê¨°
  if (wave % 5 === 0) {
    sounds.warning();
    game.flashTimer = 60;
    setTimeout(() => {
      enemies.push(new Enemy(WIDTH / 2, -150, 'boss'));
    }, 2000);
    return;
  }
  
  // ÊôÆÈÄöÊ≥¢Ê¨°
  const smallCount = Math.min(5 + wave, 12);
  const mediumCount = Math.min(Math.floor(wave / 2), 4);
  const eliteCount = wave >= 3 ? Math.min(Math.floor(wave / 3), 2) : 0;
  
  // ÁîüÊàêÁºñÈòü
  setTimeout(() => spawnFormation('small', smallCount), 0);
  if (mediumCount > 0) setTimeout(() => spawnFormation('medium', mediumCount), 1000);
  if (eliteCount > 0) setTimeout(() => spawnFormation('elite', eliteCount), 2000);
}

function spawnFormation(type, count) {
  const formations = ['line', 'v', 'random'];
  const formation = formations[Math.floor(Math.random() * formations.length)];
  
  switch(formation) {
    case 'line':
      const spacing = Math.min(80, WIDTH / (count + 1));
      for (let i = 0; i < count; i++) {
        enemies.push(new Enemy(spacing * (i + 1), -50 - i * 40, type));
      }
      break;
    case 'v':
      for (let i = 0; i < count; i++) {
        const offset = (i - count/2) * 60;
        enemies.push(new Enemy(WIDTH/2 + offset, -50 - Math.abs(offset), type));
      }
      break;
    case 'random':
      for (let i = 0; i < count; i++) {
        enemies.push(new Enemy(
          Math.random() * (WIDTH - 100) + 50,
          -50 - Math.random() * 200,
          type
        ));
      }
      break;
  }
}

// ========================================
// 11. ËæÖÂä©ÂáΩÊï∞
// ========================================
function screenShake(intensity) {
  game.shakeIntensity = Math.max(game.shakeIntensity, intensity);
}

function checkCollisions() {
  // Áé©ÂÆ∂Â≠êÂºπÂáª‰∏≠Êïå‰∫∫
  bullets.forEach(bullet => {
    enemies.forEach(enemy => {
      if (enemy.isDead) return;
      const dist = Math.hypot(bullet.x - enemy.x, bullet.y - enemy.y);
      if (dist < enemy.width/2 + bullet.width) {
        enemy.takeDamage(bullet.damage);
        bullet.y = -9999; // Ê†áËÆ∞Âà†Èô§
      }
    });
  });
  
  // Êïå‰∫∫Â≠êÂºπÂáª‰∏≠Áé©ÂÆ∂
  enemyBullets.forEach(bullet => {
    const dist = Math.hypot(bullet.x - player.x, bullet.y - player.y);
    if (dist < player.width/2 + bullet.radius) {
      player.takeDamage(bullet.damage);
      bullet.y = 9999;
    }
  });
  
  // Êïå‰∫∫ÊíûÂáªÁé©ÂÆ∂
  enemies.forEach(enemy => {
    if (enemy.isDead) return;
    const dist = Math.hypot(enemy.x - player.x, enemy.y - player.y);
    if (dist < (enemy.width + player.width) / 2) {
      player.takeDamage(30);
      enemy.takeDamage(enemy.maxHp); // Êïå‰∫∫‰πüÊ≠ª‰∫°
    }
  });
}

function gameOver() {
  game.state = GameState.GAMEOVER;
  
  if (game.score > game.bestScore) {
    game.bestScore = game.score;
    localStorage.setItem('thunderFighterBest', game.bestScore);
  }
}

function resetGame() {
  game.state = GameState.PLAYING;
  game.score = 0;
  game.wave = 1;
  game.kills = 0;
  game.combo = 0;
  game.maxCombo = 0;
  game.time = 0;
  game.comboTimer = 0;
  
  player.x = WIDTH / 2;
  player.y = HEIGHT - 150;
  player.hp = player.maxHp;
  player.weapon = 1;
  player.bombs = 2;
  player.shield = 0;
  player.invulnerable = 60;
  
  bullets.length = 0;
  enemyBullets.length = 0;
  enemies.length = 0;
  powerups.length = 0;
  particles.length = 0;
  
  waveTimer = 0;
  spawnWave();
}

// ========================================
// 12. UIÁªòÂà∂
// ========================================
function drawHUD() {
  ctx.save();
  
  // ÂçäÈÄèÊòéÈ°∂Ê†è
  ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
  ctx.fillRect(0, 0, WIDTH, 80);
  
  ctx.font = 'bold 18px sans-serif';
  ctx.textAlign = 'left';
  ctx.fillStyle = '#ffffff';
  
  // ÂàÜÊï∞
  ctx.fillText(`ÂàÜÊï∞: ${game.score}`, 20, 30);
  ctx.fillStyle = '#ffaa00';
  ctx.font = '14px sans-serif';
  ctx.fillText(`ÊúÄÈ´ò: ${game.bestScore}`, 20, 50);
  
  // Ê≥¢Ê¨°
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 18px sans-serif';
  ctx.fillText(`Á¨¨ ${game.wave} Ê≥¢`, 20, 70);
  
  // ËøûÂáª
  if (game.combo > 1) {
    ctx.font = 'bold 24px sans-serif';
    ctx.fillStyle = '#ff00ff';
    ctx.textAlign = 'center';
    ctx.fillText(`${game.combo}x COMBO!`, WIDTH/2, 35);
  }
  
  // Ê≠¶Âô®Á≠âÁ∫ß
  ctx.textAlign = 'right';
  ctx.font = '16px sans-serif';
  ctx.fillStyle = '#00ffff';
  ctx.fillText(`Ê≠¶Âô® Lv.${player.weapon}`, WIDTH - 20, 30);
  
  // ÁÇ∏Âºπ
  ctx.fillText(`üí£ √ó ${player.bombs}`, WIDTH - 20, 55);
  
  // HPÊù°
  const hpBarWidth = 200;
  const hpBarHeight = 20;
  const hpBarX = WIDTH - hpBarWidth - 20;
  const hpBarY = 60;
  
  ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
  ctx.fillRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
  
  const hpPercent = player.hp / player.maxHp;
  const gradient = ctx.createLinearGradient(hpBarX, 0, hpBarX + hpBarWidth, 0);
  gradient.addColorStop(0, hpPercent > 0.5 ? '#00ff00' : '#ff3333');
  gradient.addColorStop(1, hpPercent > 0.5 ? '#00dd00' : '#dd0000');
  ctx.fillStyle = gradient;
  ctx.fillRect(hpBarX, hpBarY, hpBarWidth * hpPercent, hpBarHeight);
  
  // ËæπÊ°ÜÂíåÂèëÂÖâ
  ctx.strokeStyle = '#ffffff';
  ctx.lineWidth = 2;
  ctx.strokeRect(hpBarX, hpBarY, hpBarWidth, hpBarHeight);
  
  if (hpPercent > 0.7) {
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 10;
    ctx.strokeRect(hpBarX, hpBarY, hpBarWidth * hpPercent, hpBarHeight);
    ctx.shadowBlur = 0;
  }
  
  ctx.fillStyle = '#ffffff';
  ctx.font = '12px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillText(`${Math.ceil(player.hp)} / ${player.maxHp}`, hpBarX + hpBarWidth/2, hpBarY + 15);
  
  ctx.restore();
}

function drawStartScreen() {
  ctx.save();
  
  // Ê†áÈ¢ò
  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#00ffff';
  ctx.shadowColor = '#00ffff';
  ctx.shadowBlur = 20;
  ctx.fillText('Èõ∑ÈúÜÊàòÊú∫', WIDTH/2, HEIGHT/3);
  ctx.shadowBlur = 0;
  
  ctx.font = 'bold 28px sans-serif';
  ctx.fillStyle = '#ffaa00';
  ctx.fillText('THUNDER FIGHTER', WIDTH/2, HEIGHT/3 + 45);
  
  // ËØ¥Êòé
  ctx.font = '18px sans-serif';
  ctx.fillStyle = '#ffffff';
  ctx.fillText('Ëá™Âä®Â∞ÑÂáª | Ë∫≤ÈÅøÂºπÂπï', WIDTH/2, HEIGHT/2);
  ctx.fillText('Ëß¶Êë∏/Èº†Ê†áÊãñÂä® - ÁßªÂä®ÊàòÊú∫', WIDTH/2, HEIGHT/2 + 35);
  ctx.fillText('Á©∫Ê†º - ‰ΩøÁî®ÁÇ∏Âºπ (PC)', WIDTH/2, HEIGHT/2 + 65);
  
  // ÂºÄÂßãÊèêÁ§∫ÔºàÈó™ÁÉÅÔºâ
  if (Math.floor(game.time / 30) % 2 === 0) {
    ctx.font = 'bold 32px sans-serif';
    ctx.fillStyle = '#00ff00';
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 15;
    ctx.fillText('ÁÇπÂáªÂºÄÂßãÊ∏∏Êàè', WIDTH/2, HEIGHT * 0.75);
    ctx.shadowBlur = 0;
  }
  
  // ÊúÄÈ´òÂàÜ
  if (game.bestScore > 0) {
    ctx.font = '20px sans-serif';
    ctx.fillStyle = '#ffff00';
    ctx.fillText(`ÊúÄÈ´òÂàÜ: ${game.bestScore}`, WIDTH/2, HEIGHT * 0.85);
  }
  
  ctx.restore();
}

function drawGameOverScreen() {
  ctx.save();
  
  // ÂçäÈÄèÊòéËÉåÊôØ
  ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  
  // GAME OVER
  ctx.font = 'bold 56px sans-serif';
  ctx.textAlign = 'center';
  ctx.fillStyle = '#ff3333';
  ctx.shadowColor = '#ff0000';
  ctx.shadowBlur = 25;
  const pulse = 1 + Math.sin(game.time / 10) * 0.1;
  ctx.save();
  ctx.translate(WIDTH/2, HEIGHT/3);
  ctx.scale(pulse, pulse);
  ctx.fillText('GAME OVER', 0, 0);
  ctx.restore();
  ctx.shadowBlur = 0;
  
  // ÁªüËÆ°
  ctx.font = '24px sans-serif';
  ctx.fillStyle = '#ffffff';
  const stats = [
    `ÊúÄÁªàÂàÜÊï∞: ${game.score}`,
    `ÊúÄÈ´òÂàÜÊï∞: ${game.bestScore}`,
    `ÂáªÊùÄ: ${game.kills}`,
    `ÊúÄÂ§ßËøûÂáª: ${game.maxCombo}x`,
    `Âà∞ËææÊ≥¢Ê¨°: ${game.wave}`
  ];
  
  stats.forEach((stat, i) => {
    ctx.fillText(stat, WIDTH/2, HEIGHT/2 + i * 35);
  });
  
  // ÈáçÊñ∞ÂºÄÂßãÊèêÁ§∫
  if (Math.floor(game.time / 30) % 2 === 0) {
    ctx.font = 'bold 28px sans-serif';
    ctx.fillStyle = '#00ff00';
    ctx.shadowColor = '#00ff00';
    ctx.shadowBlur = 15;
    ctx.fillText('ÁÇπÂáªÈáçÊñ∞ÂºÄÂßã', WIDTH/2, HEIGHT * 0.8);
    ctx.shadowBlur = 0;
  }
  
  ctx.restore();
}

function drawBossWarning() {
  if (game.flashTimer > 40) {
    ctx.save();
    ctx.font = 'bold 64px sans-serif';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#ff0000';
    ctx.shadowColor = '#ff0000';
    ctx.shadowBlur = 30;
    
    const alpha = (game.flashTimer - 40) / 20;
    ctx.globalAlpha = alpha;
    
    if (Math.floor(game.time / 10) % 2 === 0) {
      ctx.fillText('‚ö†Ô∏è WARNING! ‚ö†Ô∏è', WIDTH/2, HEIGHT/2);
    }
    
    ctx.restore();
  }
}

// ========================================
// 13. Ê∏∏ÊàèÊõ¥Êñ∞Âæ™ÁéØ
// ========================================
function update() {
  if (game.state !== GameState.PLAYING) return;
  
  game.time++;
  
  // ËøûÂáªËÆ°Êó∂Âô®
  if (game.comboTimer > 0) {
    game.comboTimer--;
    if (game.comboTimer === 0) {
      game.combo = 0;
    }
  }
  
  // Êõ¥Êñ∞ÊòüÁ©∫
  stars.forEach(star => star.update());
  
  // Êõ¥Êñ∞Áé©ÂÆ∂
  player.update();
  
  // Êõ¥Êñ∞Â≠êÂºπ
  bullets.forEach(b => b.update());
  bullets.filter((b, i) => {
    if (b.isOffScreen()) {
      bullets.splice(i, 1);
      return false;
    }
    return true;
  });
  
  enemyBullets.forEach(b => b.update());
  enemyBullets.filter((b, i) => {
    if (b.isOffScreen()) {
      enemyBullets.splice(i, 1);
      return false;
    }
    return true;
  });
  
  // Êõ¥Êñ∞Êïå‰∫∫
  enemies.forEach(e => e.update());
  enemies.filter((e, i) => {
    if (e.isDead || e.isOffScreen()) {
      enemies.splice(i, 1);
      return false;
    }
    return true;
  });
  
  // Êõ¥Êñ∞ÈÅìÂÖ∑
  powerups.forEach(p => p.update());
  powerups.filter((p, i) => {
    if (p.collected || p.isOffScreen()) {
      powerups.splice(i, 1);
      return false;
    }
    return true;
  });
  
  // Êõ¥Êñ∞Á≤íÂ≠ê
  particles.forEach(p => p.update());
  particles.filter((p, i) => {
    if (p.isDead()) {
      particles.splice(i, 1);
      return false;
    }
    return true;
  });
  
  // Á¢∞ÊíûÊ£ÄÊµã
  checkCollisions();
  
  // Ê≥¢Ê¨°ÁîüÊàê
  if (enemies.length === 0) {
    waveTimer++;
    if (waveTimer >= nextWaveDelay) {
      spawnWave();
      waveTimer = 0;
    }
  }
  
  // Èó™Â±è
  if (game.flashTimer > 0) game.flashTimer--;
  
  // Â±èÂπïÈúáÂä®
  if (game.shakeIntensity > 0) {
    game.shakeX = (Math.random() - 0.5) * game.shakeIntensity;
    game.shakeY = (Math.random() - 0.5) * game.shakeIntensity;
    game.shakeIntensity *= 0.9;
    if (game.shakeIntensity < 0.5) {
      game.shakeIntensity = 0;
      game.shakeX = 0;
      game.shakeY = 0;
    }
  }
}

// ========================================
// 14. Ê∏∏ÊàèÁªòÂà∂Âæ™ÁéØ
// ========================================
function draw() {
  // Ê∏ÖÂ±è
  ctx.fillStyle = '#000814';
  ctx.fillRect(0, 0, WIDTH, HEIGHT);
  
  ctx.save();
  ctx.translate(game.shakeX, game.shakeY);
  
  // ËÉåÊôØÊòüÁ©∫
  stars.forEach(star => star.draw());
  
  if (game.state === GameState.START) {
    drawStartScreen();
  } else if (game.state === GameState.PLAYING) {
    // Ê∏∏ÊàèÂÖÉÁ¥†
    particles.forEach(p => p.draw());
    powerups.forEach(p => p.draw());
    bullets.forEach(b => b.draw());
    enemyBullets.forEach(b => b.draw());
    enemies.forEach(e => e.draw());
    player.draw();
    
    drawHUD();
    drawBossWarning();
    
    // ÁÇ∏ÂºπÈó™ÂÖâ
    if (game.flashTimer > 0) {
      ctx.fillStyle = `rgba(255, 255, 255, ${game.flashTimer / 40})`;
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
    }
  } else if (game.state === GameState.GAMEOVER) {
    // ÁªßÁª≠ÊòæÁ§∫Ê∏∏ÊàèÂÖÉÁ¥†ÔºàÈùôÊ≠¢Ôºâ
    particles.forEach(p => p.draw());
    powerups.forEach(p => p.draw());
    bullets.forEach(b => b.draw());
    enemyBullets.forEach(b => b.draw());
    enemies.forEach(e => e.draw());
    player.draw();
    
    drawGameOverScreen();
  }
  
  ctx.restore();
}

// ========================================
// 15. ËæìÂÖ•ÊéßÂà∂
// ========================================
let touchId = null;

function handlePointerDown(x, y) {
  // ÊÅ¢Â§çÈü≥È¢ë‰∏ä‰∏ãÊñá
  if (audioCtx.state === 'suspended') {
    audioCtx.resume();
  }
  
  if (game.state === GameState.START) {
    resetGame();
  } else if (game.state === GameState.GAMEOVER) {
    resetGame();
  }
}

function handlePointerMove(x, y) {
  if (game.state === GameState.PLAYING) {
    player.x = x;
    player.y = y;
  }
}

// Èº†Ê†á‰∫ã‰ª∂
canvas.addEventListener('mousedown', (e) => {
  handlePointerDown(e.clientX, e.clientY);
});

canvas.addEventListener('mousemove', (e) => {
  handlePointerMove(e.clientX, e.clientY);
});

// Ëß¶Êë∏‰∫ã‰ª∂
canvas.addEventListener('touchstart', (e) => {
  e.preventDefault();
  const touch = e.touches[0];
  touchId = touch.identifier;
  handlePointerDown(touch.clientX, touch.clientY);
}, { passive: false });

canvas.addEventListener('touchmove', (e) => {
  e.preventDefault();
  for (let touch of e.touches) {
    if (touch.identifier === touchId) {
      handlePointerMove(touch.clientX, touch.clientY);
      break;
    }
  }
}, { passive: false });

canvas.addEventListener('touchend', (e) => {
  e.preventDefault();
  for (let touch of e.changedTouches) {
    if (touch.identifier === touchId) {
      touchId = null;
      break;
    }
  }
}, { passive: false });

// ÈîÆÁõò‰∫ã‰ª∂
window.addEventListener('keydown', (e) => {
  if (e.code === 'Space') {
    e.preventDefault();
    if (game.state === GameState.PLAYING) {
      player.useBomb();
    } else if (game.state === GameState.START || game.state === GameState.GAMEOVER) {
      resetGame();
    }
  }
});

// ========================================
// 16. Ê∏∏Êàè‰∏ªÂæ™ÁéØ
// ========================================
function gameLoop() {
  update();
  draw();
  requestAnimationFrame(gameLoop);
}

// ÂêØÂä®Ê∏∏Êàè
gameLoop();

})();
</script>
</body>
</html>
