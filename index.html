<!doctype html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<title>Space Fighter - Mobile Safe</title>
<style>
  html, body { margin:0; padding:0; width:100%; height:100%; overflow:hidden; background:#0a0a0a; }
  canvas { display:block; width:100vw; height:100vh; background:#0a0a0a; touch-action:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');
  let w = innerWidth, h = innerHeight;
  function resize(){
    w = innerWidth; h = innerHeight;
    canvas.width = w; canvas.height = h;
    if(stars.length===0 || stars[0].y>h+10) initStars();
  }
  window.addEventListener('resize', resize);
  resize();

  const colors = {
    bg: '#0a0a0a', player: '#00ffcc', bullet: '#ffffff', enemy: '#ff3b30',
    elite: '#9b59ff', boss: '#ff9f1c', text: '#ffffff'
  };

  const state = {
    mode: 'start', // start | playing | over
    time:0,
    score:0,
    best: parseInt(localStorage.getItem('sf_best_v2')||'0'),
    wave:1,
    player:null,
    bullets:[],
    enemies:[],
    enemyBullets:[],
    particles:[],
    drops:[],
    keys:{},
    firing:false,
    bannerTimer:0,
    bannerText:'',
    waveCooldown:0,
    shake:0,
  };

  const stars = [];
  function initStars(){
    stars.length = 0;
    for(let i=0;i<120;i++){
      stars.push({x:Math.random()*w, y:Math.random()*h, s:Math.random()*2+0.5, spd:Math.random()*0.8+0.4});
    }
  }
  initStars();

  function resetGame(){
    state.mode='playing';
    state.time=0; state.score=0; state.wave=1; state.shake=0;
    state.bullets=[]; state.enemies=[]; state.enemyBullets=[]; state.particles=[]; state.drops=[];
    state.waveCooldown=40; state.bannerTimer=0; state.bannerText='';
    state.player = {x:w/2, y:h-120, r:16, hp:100, maxHp:100, speed:6, weapon:0, cooldown:0, bombs:1, inv:0};
  }

  const weaponDefs = [
    {name:'Single', rate:12, spread:[0], speed:11},
    {name:'Dual', rate:11, spread:[-0.04,0.04], speed:11},
    {name:'Triple', rate:10, spread:[-0.12,0,0.12], speed:11},
    {name:'Fan', rate:9, spread:[-0.2,-0.1,0,0.1,0.2], speed:11}
  ];

  function shoot(){
    if(state.mode!=='playing') return;
    const p=state.player; if(p.cooldown>0) return;
    const def = weaponDefs[p.weapon];
    def.spread.forEach(angle=>{
      state.bullets.push({x:p.x, y:p.y-p.r, vx:Math.sin(angle)*def.speed, vy:-Math.cos(angle)*def.speed, r:4, friendly:true, color:colors.bullet});
    });
    p.cooldown = def.rate;
  }

  function useBomb(){
    if(state.mode!=='playing') return;
    const p=state.player; if(p.bombs<=0) return;
    p.bombs--;
    state.enemies.forEach(e=>{explode(e.x,e.y, e.type==='boss'?80:40); state.score += e.type==='boss'?500:120;});
    state.enemies=[]; state.enemyBullets=[]; state.drops=[]; state.shake=14;
  }

  function spawnWave(){
    const wave = state.wave;
    const normalCount = Math.min(8+wave*2, 45);
    const eliteCount = Math.floor(Math.max(0, wave-2)/2);
    for(let i=0;i<normalCount;i++){
      state.enemies.push({type:'normal', x:Math.random()*w, y:-Math.random()*300-20, vx:(Math.random()*2-1)*(1+wave*0.05), vy:2+wave*0.08, r:15, hp: 20+wave*2, cd:60});
    }
    for(let i=0;i<eliteCount;i++){
      state.enemies.push({type:'elite', x:Math.random()*w, y:-Math.random()*300-20, vx:(Math.random()*2-1)*(0.8+wave*0.04), vy:1.6+wave*0.06, r:24, hp: 70+wave*5, cd:50});
    }
    if(wave%5===0){
      state.enemies.push({type:'boss', x:w/2, y:-140, vx:1.2, vy:1.5, r:70, hp:450+wave*60, maxHp:450+wave*60, cd:40});
    }
    state.bannerText = `WAVE ${wave}`; state.bannerTimer = 120;
  }

  function explode(x,y,count=30,color){
    for(let i=0;i<count;i++){
      const a=Math.random()*Math.PI*2; const s=Math.random()*4+1;
      state.particles.push({x,y,vx:Math.cos(a)*s, vy:Math.sin(a)*s, life:40, color: color || `hsl(${Math.random()*360},80%,60%)`});
    }
    state.shake = Math.min(16, state.shake+4);
  }

  function drop(x,y){
    const types=['heal','weapon','bomb'];
    const t = types[Math.floor(Math.random()*types.length)];
    state.drops.push({x,y,vy:2.2, r:12, type:t});
  }

  function hitPlayer(dmg){
    const p=state.player; if(p.inv>0) return; p.hp -= dmg; p.inv = 40; state.shake=10; if(p.hp<=0) endGame();
  }

  function endGame(){
    state.mode='over';
    state.best = Math.max(state.best, state.score);
    localStorage.setItem('sf_best_v2', state.best);
  }

  // Input
  window.addEventListener('keydown',e=>{
    if(e.key===' '){ e.preventDefault(); if(state.mode==='playing') useBomb(); else if(state.mode==='start') { resetGame(); }}
  });

  // Mouse controls (PC)
  window.addEventListener('mousemove',e=>{
    if(state.mode==='playing'){
      state.player.x = e.clientX; state.player.y = e.clientY;
    }
  });
  let mouseDown=false;
  window.addEventListener('mousedown',e=>{
    if(state.mode==='start'){ resetGame(); return; }
    if(state.mode==='over'){ resetGame(); return; }
    mouseDown=true; shoot();
  });
  window.addEventListener('mouseup',()=>{mouseDown=false;});

  // Touch controls: left half move, right half shoot
  let touchMoveId=null;
  window.addEventListener('touchstart',e=>{
    e.preventDefault();
    if(state.mode==='start'){ resetGame(); return; }
    if(state.mode==='over'){ resetGame(); return; }
    for(const t of e.changedTouches){
      if(t.clientX < w/2 && touchMoveId===null){
        touchMoveId = t.identifier;
        state.player.x = t.clientX; state.player.y = t.clientY;
      } else if(t.clientX >= w/2){
        state.firing = true; shoot();
      }
    }
  }, {passive:false});
  window.addEventListener('touchmove',e=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      if(t.identifier===touchMoveId){
        state.player.x = t.clientX; state.player.y = t.clientY;
      }
    }
  }, {passive:false});
  window.addEventListener('touchend',e=>{
    e.preventDefault();
    for(const t of e.changedTouches){
      if(t.identifier===touchMoveId) touchMoveId=null;
      if(t.clientX >= w/2) state.firing=false;
    }
  }, {passive:false});

  // Game loop
  function update(){
    state.time++;
    // Stars
    for(const s of stars){ s.y += s.spd; if(s.y>h) { s.y=0; s.x=Math.random()*w; } }

    if(state.mode!=='playing') return;
    const p=state.player;
    // keep in bounds
    p.x = Math.max(p.r, Math.min(w-p.r, p.x));
    p.y = Math.max(p.r+10, Math.min(h-p.r-10, p.y));

    if(p.cooldown>0) p.cooldown-=1;
    if(p.inv>0) p.inv-=1;

    if(state.firing || mouseDown) shoot();

    // bullets move
    state.bullets.forEach(b=>{b.x+=b.vx; b.y+=b.vy;});
    state.bullets = state.bullets.filter(b=>b.y>-60 && b.y<h+60 && b.x>-60 && b.x<w+60);

    // spawn logic
    if(state.enemies.length===0 && state.waveCooldown<=0){
      spawnWave();
    } else if(state.enemies.length===0){
      state.waveCooldown--;
    }

    // enemies update
    state.enemies.forEach(e=>{
      e.x += e.vx; e.y += e.vy;
      if(e.x<e.r || e.x>w-e.r) e.vx*=-1;
      if(e.type==='boss'){
        if(e.cd--<=0){ e.cd = Math.max(24, 46 - state.wave*2); state.enemyBullets.push({x:e.x, y:e.y+e.r, vy:4+state.wave*0.25, r:7, color:colors.boss}); }
      } else {
        if(Math.random()<0.002*state.wave){ state.enemyBullets.push({x:e.x,y:e.y+e.r,vy:4+state.wave*0.15,r:5,color:'#ff6b6b'}); }
      }
    });
    state.enemies = state.enemies.filter(e=>e.y < h+160 && e.hp>0);

    // enemy bullets
    state.enemyBullets.forEach(b=>{ b.y += b.vy; });
    state.enemyBullets = state.enemyBullets.filter(b=>b.y < h+40);

    // player bullets hit enemies
    for(const b of state.bullets){
      for(const e of state.enemies){
        const dx=b.x-e.x, dy=b.y-e.y; const dist=Math.hypot(dx,dy);
        if(dist < e.r + b.r){
          e.hp -= (e.type==='boss'?6:10);
          b.y = -999; // remove
          state.score += 10;
          if(e.hp<=0){
            explode(e.x,e.y, e.type==='boss'?90:35);
            if(Math.random()<0.25) drop(e.x,e.y);
            state.score += e.type==='boss'?800:(e.type==='elite'?200:120);
          }
        }
      }
    }
    state.bullets = state.bullets.filter(b=>b.y>-500);

    // enemy bullets hit player
    for(const b of state.enemyBullets){
      const dx=b.x-p.x, dy=b.y-p.y; const dist=Math.hypot(dx,dy);
      if(dist < p.r+ b.r){
        hitPlayer(18);
        b.y = h+999;
      }
    }

    // enemies collide player
    for(const e of state.enemies){
      const dx=e.x-p.x, dy=e.y-p.y; const dist=Math.hypot(dx,dy);
      if(dist < e.r + p.r){ hitPlayer(26); e.hp=0; explode(e.x,e.y,30); }
    }

    // drops
    state.drops.forEach(d=>{
      d.y += d.vy;
      const dx=d.x-p.x, dy=d.y-p.y; if(Math.hypot(dx,dy) < d.r+p.r){
        if(d.type==='heal') p.hp = Math.min(p.maxHp, p.hp+40);
        if(d.type==='weapon') p.weapon = Math.min(weaponDefs.length-1, p.weapon+1);
        if(d.type==='bomb') p.bombs +=1;
        d.y = h+200;
      }
    });
    state.drops = state.drops.filter(d=>d.y < h+60);

    if(state.enemies.length===0 && state.waveCooldown<=0){ state.wave++; state.waveCooldown=60; }
  }

  function drawTextCentered(text, y, size=28){
    ctx.fillStyle=colors.text; ctx.font=`${size}px 'Segoe UI', sans-serif`; ctx.textAlign='center'; ctx.fillText(text, w/2, y);
  }

  function drawHUD(){
    const p=state.player;
    ctx.fillStyle=colors.text; ctx.font='14px sans-serif'; ctx.textAlign='left';
    ctx.fillText(`Score: ${state.score}`, 16, 24);
    ctx.fillText(`Best: ${state.best}`, 16, 44);
    ctx.fillText(`Wave: ${state.wave}`, 16, 64);
    ctx.fillText(`Weapon: ${weaponDefs[p.weapon].name}`, 16, 84);
    ctx.fillText(`Bombs: ${p.bombs}`, 16, 104);
    // HP bar
    ctx.strokeStyle='#555'; ctx.lineWidth=2; ctx.strokeRect(14,112,160,12);
    ctx.fillStyle='#00ff88'; ctx.fillRect(14,112,160*(p.hp/p.maxHp),12);
  }

  function drawStart(){
    drawTextCentered('NEON SPACE FIGHTER', h*0.4, 34);
    ctx.font='16px sans-serif'; ctx.textAlign='center'; ctx.fillStyle=colors.text;
    ctx.fillText('鼠标移动 / 左半屏触摸 移动战机', w/2, h*0.45+30);
    ctx.fillText('点击或右半屏触摸 射击 · 空格炸弹 (PC)', w/2, h*0.45+55);
    ctx.fillText('点击 / 触摸开始', w/2, h*0.45+90);
  }

  function drawGameOver(){
    drawTextCentered('GAME OVER', h*0.45, 36);
    ctx.font='18px sans-serif'; ctx.textAlign='center'; ctx.fillStyle=colors.text;
    ctx.fillText(`Score: ${state.score}`, w/2, h*0.45+36);
    ctx.fillText(`Best: ${state.best}`, w/2, h*0.45+60);
    ctx.fillText('点击 / 触摸重新开始', w/2, h*0.45+96);
  }

  function draw(){
    ctx.clearRect(0,0,w,h);
    // bg
    ctx.fillStyle=colors.bg; ctx.fillRect(0,0,w,h);
    ctx.fillStyle='rgba(255,255,255,0.6)';
    stars.forEach(s=>{ ctx.fillRect(s.x, s.y, s.s*0.8, s.s*1.4); });

    ctx.save();
    if(state.shake>0){
      const s = state.shake; state.shake = Math.max(0, state.shake-0.6);
      ctx.translate((Math.random()-0.5)*s, (Math.random()-0.5)*s);
    }

    // player
    if(state.player){
      const p=state.player;
      // exhaust
      for(let i=0;i<3;i++){
        state.particles.push({x:p.x+(Math.random()*10-5), y:p.y+p.r+6, vx:(Math.random()*1-0.5), vy:Math.random()*2+1, life:16, color:'rgba(0,255,204,0.6)'});
      }
      ctx.fillStyle=colors.player;
      ctx.beginPath();
      ctx.moveTo(p.x, p.y-p.r-6);
      ctx.lineTo(p.x-p.r, p.y+p.r);
      ctx.lineTo(p.x+p.r, p.y+p.r);
      ctx.closePath();
      ctx.fill();
      ctx.strokeStyle='rgba(255,255,255,0.35)'; ctx.lineWidth=2; ctx.stroke();
      if(p.inv>0){ ctx.strokeStyle='rgba(0,255,255,0.5)'; ctx.beginPath(); ctx.arc(p.x,p.y,p.r+6,0,Math.PI*2); ctx.stroke(); }
    }

    // bullets
    for(const b of state.bullets){
      ctx.strokeStyle=b.color; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(b.x, b.y); ctx.lineTo(b.x-b.vx*0.15, b.y-b.vy*0.15); ctx.stroke();
    }

    // enemy bullets
    for(const b of state.enemyBullets){ ctx.fillStyle=b.color; ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill(); }

    // enemies
    for(const e of state.enemies){
      if(e.type==='boss'){
        ctx.fillStyle=colors.boss;
        ctx.beginPath(); ctx.arc(e.x,e.y,e.r,0,Math.PI*2); ctx.fill();
      } else if(e.type==='elite') {
        ctx.fillStyle=colors.elite;
        ctx.beginPath();
        ctx.moveTo(e.x, e.y-e.r);
        ctx.lineTo(e.x+e.r, e.y);
        ctx.lineTo(e.x, e.y+e.r);
        ctx.lineTo(e.x-e.r, e.y);
        ctx.closePath(); ctx.fill();
      } else {
        ctx.fillStyle=colors.enemy;
        ctx.beginPath();
        ctx.moveTo(e.x, e.y-e.r);
        ctx.lineTo(e.x+e.r, e.y);
        ctx.lineTo(e.x, e.y+e.r);
        ctx.lineTo(e.x-e.r, e.y);
        ctx.closePath(); ctx.fill();
      }
      if(e.type==='elite'){
        ctx.fillStyle='rgba(255,255,255,0.25)';
        ctx.fillRect(e.x-e.r, e.y+e.r+4, (e.hp/ (70+state.wave*5)) * e.r*2, 4);
      }
    }

    // boss HP bar
    const boss = state.enemies.find(e=>e.type==='boss');
    if(boss){
      ctx.fillStyle='rgba(255,255,255,0.2)'; ctx.fillRect(w/2-160, 16, 320, 14);
      ctx.fillStyle=colors.boss; ctx.fillRect(w/2-160, 16, 320*(boss.hp/boss.maxHp), 14);
      ctx.strokeStyle='rgba(255,255,255,0.4)'; ctx.strokeRect(w/2-160, 16, 320, 14);
    }

    // drops
    for(const d of state.drops){
      const cMap={heal:'#00ff88', weapon:'#61b4ff', bomb:'#ffd33d'};
      ctx.strokeStyle='#ffffff'; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(d.x,d.y,d.r,0,Math.PI*2); ctx.stroke();
      ctx.fillStyle=cMap[d.type]; ctx.fillText(d.type==='heal'?'+':d.type==='weapon'?'W':'B', d.x-4, d.y+4);
    }

    // particles
    ctx.globalCompositeOperation='lighter';
    for(const p of state.particles){ ctx.fillStyle=p.color; ctx.globalAlpha=p.life/40; ctx.fillRect(p.x,p.y,3,3); p.x+=p.vx; p.y+=p.vy; p.life--; }
    ctx.globalAlpha=1; ctx.globalCompositeOperation='source-over';
    state.particles = state.particles.filter(p=>p.life>0);

    ctx.restore();

    // HUD & overlays
    if(state.mode==='playing') drawHUD();
    if(state.mode==='start') drawStart();
    if(state.mode==='over') drawGameOver();

    if(state.bannerTimer>0){
      drawTextCentered(state.bannerText, h*0.32, 32);
      state.bannerTimer--;
    }

    ctx.textAlign='right'; ctx.font='12px sans-serif'; ctx.fillStyle='rgba(255,255,255,0.6)';
    ctx.fillText('左半屏移动 / 右半屏射击 · 空格炸弹(PC)', w-12, h-18);
  }

  function loop(){
    update();
    draw();
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>
